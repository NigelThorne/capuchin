
class Capuchin::Visitor < RKelly::Visitors::Visitor
  class DeclScanner < RKelly::Visitors::Visitor
    def initialize(scope)
      @scope = scope
    end

    def visit_ResolveNode(o)
      @scope.need_arguments! if o.value.to_sym == :arguments
    end
    def visit_VarDeclNode(o)
      name = o.name.to_sym
      @scope.add_variable name

      # Scan the value
      accept o.value if o.value
    end
    def visit_FunctionDeclNode(o)
      name = o.value.to_sym
      @scope.add_variable name

      @scope.add_method do |g,v|
        g.set_line o.line
        g.push_const :Capuchin
        g.find_const :Function
        g.push_literal o.value.to_sym
        g.create_block v.compile_method(o.line, o.value, o.arguments.map {|p| p.value }, o.function_body)
        g.send_with_block :new, 1

        var = g.state.scope.variables[o.value.to_sym]
        var.reference.set_bytecode(g)
        g.pop
      end
    end
    def visit_FunctionExprNode(o)
      # Don't scan function_body; it's a new scope
    end
  end

  class Scope
    include Rubinius::Compiler::LocalVariables
    def initialize(parent)
      @parent = parent
      @buffered_variables = []
      @methods = []
      @need_arguments = false
    end
    def need_arguments!; @need_arguments = true; end
    def need_arguments?; @need_arguments; end

    def add_variable(name)
      if @buffered_variables.include?(name)
        raise "Duplicate variable #{name}?"
      else
        @buffered_variables << name
      end
    end
    def new_local(name)
      variable = Rubinius::Compiler::LocalVariable.new allocate_slot
      variables[name] = variable
    end
    def new_nested_local(name)
      new_local(name).nested_reference
    end

    def add_method(&block)
      @methods << block
    end
    def append_buffered_definitions(g, v)
      @buffered_variables.each do |var|
        new_local(var)
      end
      @methods.each do |defn|
        defn.call(g, v)
      end
    end

    def search_local(name)
      if variable = variables[name]
        variable.nested_reference
      elsif @parent && reference = @parent.search_local(name)
        reference.depth += 1
        reference
      end
    end
  end

  def initialize(g, scope=nil)
    @g = g
    @scope = scope || Scope.new(nil)
    @g.push_state scope if scope
  end
  def with_scope(scope=Scope.new(@scope))
    old_scope, @scope = @scope, scope
    @g.push_state @scope
    yield
  ensure
    @g.pop_state
    @scope = old_scope
  end

  def visit_TrueNode(o)
    @g.set_line o.line
    @g.push_true
  end
  def visit_FalseNode(o)
    @g.set_line o.line
    @g.push_false
  end
  def visit_NullNode(o)
    @g.set_line o.line
    @g.push_nil
  end
  def visit_ThisNode(o)
    @g.set_line o.line
    @g.push_self
  end
  def visit_FunctionExprNode(o)
    @g.set_line o.line
    @g.push_const :Capuchin
    @g.find_const :Function
    @g.push_literal o.value.to_sym
    @g.create_block compile_method(o.line, o.value, o.arguments.map {|p| p.value }, o.function_body)
    @g.send_with_block :new, 1
  end
  def visit_FunctionDeclNode(o)
    # The entire definition was pulled up by DeclScanner; nothing to do
    # now.
  end

  def new_generator(name, arguments=[])
    meth = @g.class.new
    meth.name = name.to_sym
    meth.file = @g.file

    meth.required_args = #0
    meth.total_args = arguments.size

    meth
  end
  def new_visitor(g)
    self.class.new(g)
  end
  def compile_method(line, name, arguments, body)
    meth = new_generator(name, arguments)

    v = new_visitor(meth)

    v.with_scope(Scope.new(@scope)) do
      #meth.state.push_super self

      meth.state.push_name name

      meth.set_line line

      body.accept DeclScanner.new(meth.state.scope)

      if meth.state.scope.need_arguments? || arguments.size > 0
        # We use "block-style" arguments; our parameters are in an
        # array-like object on the stack
        meth.cast_for_splat_block_arg

        if meth.state.scope.need_arguments?
          unless arguments.empty?
            meth.dup
            meth.send :dup, 0
          end
          var = meth.state.scope.new_local(:arguments)
          var.reference.set_bytecode(meth)
          meth.pop
        end

        unless arguments.empty?
          arguments.each do |a|
            var = meth.state.scope.new_local(a.to_sym)
            meth.shift_array
            var.reference.set_bytecode(meth)
            meth.pop
          end
          meth.pop
        end

        # Marker between arg processing and function body, for quick scanning of
        # the generated bytecode
        meth.noop
      end

      meth.state.scope.append_buffered_definitions meth, v
      body.accept v

      meth.state.pop_name

      meth.local_count = meth.state.scope.local_count
      meth.local_names = meth.state.scope.local_names

      meth.push_nil
      meth.ret
      meth.close
    end

    meth
  end

  def visit_VarDeclNode(o)
    @g.set_line o.line

    var = @g.state.scope.variables[o.name.to_sym]
    if o.value
      accept o.value
      var.reference.set_bytecode(@g)
      @g.pop
    end
  end
  def visit_ResolveNode(o)
    @g.set_line o.line
    if ref = @g.state.scope.search_local(o.value.to_sym)
      ref.get_bytecode(@g)
    else
      @g.push_const :Capuchin
      @g.find_const :Globals
      @g.push_literal o.value.to_sym
      @g.send :[], 1
    end
  end
  def visit_ExpressionStatementNode(o)
    @g.set_line o.line
    accept o.value
    @g.pop
  end
  def visit_ArrayNode(o)
    @g.set_line o.line
    o.value.each do |entry|
      accept entry
    end
    @g.make_array o.value.size
  end
  def visit_DotAccessorNode(o)
    @g.set_line o.line
    accept o.value
    @g.push_literal o.accessor.to_sym
    @g.send :js_get, 1
    #@g.call_custom :js_get, 1
  end
  def visit_BracketAccessorNode(o)
    @g.set_line o.line
    accept o.value
    accept o.accessor
    @g.send :js_key, 0
    @g.send :js_get, 1
    #@g.call_custom :js_get, 1
  end
  def visit_StringNode(o)
    @g.set_line o.line
    str = o.value[1, o.value.size - 2]
    #str.gsub # FIXME: Escapes: \\, \", \n, \u..., \0..
    @g.push_literal str
  end
  def visit_NumberNode(o)
    @g.set_line o.line
    @g.push_literal o.value
  end
  def visit_ObjectLiteralNode(o)
    @g.push_const :Hash
    @g.send :new, 0
    o.value.each do |prop|
      accept prop
    end
  end
  def visit_PropertyNode(o)
    @g.dup
    @g.push_literal o.name.to_sym
    accept o.value
    @g.send :[]=, 2
    @g.pop
  end
  def visit_IfNode(o)
    @g.set_line o.line
    accept o.conditions
    after = @g.new_label
    if o.else
      alternate = @g.new_label
      @g.giz alternate, o.conditions
      accept o.value
      @g.goto after
      alternate.set!
      accept o.else
    else
      @g.giz after, o.conditions
      accept o.value
    end
    after.set!
  end
  def visit_TypeOfNode(o)
    @g.set_line o.line
    accept o.value
    @g.send :js_typeof, 0
  end
  def visit_VoidNode(o)
    @g.set_line o.line
    accept o.value
    @g.pop
    @g.push_nil
  end
  def visit_CommaNode(o)
    @g.set_line o.line
    accept o.left
    @g.pop
    accept o.value
  end
  def visit_NewExprNode(o)
    @g.set_line o.line
    accept o.value
    args = o.arguments.value
    args.each do |arg|
      accept arg
    end
    @g.send :js_new, args.size
  end
  def visit_ForInNode(o)
    raise NotImplementedError, "for .. in"
  end
  def visit_BreakNode(o)
    raise NotImplementedError, "break"
  end
  def visit_ContinueNode(o)
    raise NotImplementedError, "continue"
  end

  def visit_ForNode(o)
    @g.set_line o.line
    accept o.init

    top = @g.new_label
    done = @g.new_label

    top.set!
    accept o.test
    @g.giz done, o.test

    accept o.value
    accept o.counter
    @g.pop
    @g.goto top

    done.set!
  end
  def visit_DoWhileNode(o)
    @g.set_line o.line
    again = @g.new_label

    again.set!
    accept o.left
    accept o.value
    @g.giz again, o.value
  end
  def visit_WhileNode(o)
    @g.set_line o.line
    again = @g.new_label
    nope = @g.new_label

    again.set!
    accept o.left
    @g.giz nope, o.left

    accept o.value
    @g.goto again

    nope.set!
  end

  def visit_TryNode(o)
    # FIXME: Ignores catch
    accept o.value
    accept o.finally_block if o.finally_block
  end

  def visit_ReturnNode(o)
    @g.set_line o.line

    if o.value
      accept o.value
    else
      @g.push_nil
    end
    @g.ret
  end

  def visit_PrefixNode(o)
    # FIXME: Double-evaluates operand
    accept o.operand
    @g.meta_push_1
    case o.value
    when '++'
      @g.meta_send_op_plus @g.find_literal(:+)
    when '--'
      @g.meta_send_op_minus @g.find_literal(:-)
    end
    assign_to o.operand
  end
  def visit_PostfixNode(o)
    # FIXME: Double-evaluates operand
    accept o.operand
    @g.dup
    @g.meta_push_1
    case o.value
    when '++'
      @g.meta_send_op_plus @g.find_literal(:+)
    when '--'
      @g.meta_send_op_minus @g.find_literal(:-)
    end
    assign_to o.operand
    @g.pop
  end

  [
    [:Add, :js_add],
    [:BitAnd, '&'],
    [:BitOr, '|'],
    [:BitXOr, '^'],
    [:Divide, :js_div],
    [:LeftShift, '<<'],
    [:Modulus, '%'],
    [:Multiply, '*'],
    [:RightShift, '>>'],
    [:Subtract, '-'],
  ].each do |name,op|
    define_method(:"visit_#{name}Node") do |o|
      @g.set_line o.line
      accept o.left
      accept o.value
      @g.send op.to_sym, 1
    end
  end

  def visit_LogicalNotNode(o)
    @g.set_line o.line
    a = @g.new_label
    b = @g.new_label
    accept o.value
    @g.gnz a, o.value
    @g.push_true
    @g.goto b
    a.set!
    @g.push_false
    b.set!
  end
  def visit_LogicalAndNode(o)
    @g.set_line o.line
    done = @g.new_label
    accept o.left
    @g.dup
    @g.giz done, o.left
    @g.pop
    accept o.value
    done.set!
  end
  def visit_LogicalOrNode(o)
    @g.set_line o.line
    done = @g.new_label
    accept o.left
    @g.dup
    @g.gnz done, o.left
    @g.pop
    accept o.value
    done.set!
  end

  [
    [:Greater, '>'],
    [:GreaterOrEqual, '>='],
    [:Less, '<'],
    [:LessOrEqual, '<='],
  ].each do |name,op|
    define_method(:"visit_#{name}Node") do |o|
      @g.set_line o.line
      accept o.left
      accept o.value
      @g.send op.to_sym, 1
    end
  end

  def visit_EqualNode(o)
    @g.set_line o.line
    accept o.left
    accept o.value
    @g.send :js_equal, 1
  end
  def visit_StrictEqualNode(o)
    @g.set_line o.line
    accept o.left
    accept o.value
    @g.send :js_strict_equal, 1
  end
  def visit_NotEqualNode(o)
    @g.set_line o.line
    accept o.left
    accept o.value
    @g.send :js_equal, 1

    alt = @g.new_label
    done = @g.new_label
    @g.git alt
    @g.push_true
    @g.goto done

    alt.set!
    @g.push_false
    done.set!
  end
  def visit_NotStrictEqualNode(o)
    @g.set_line o.line
    accept o.left
    accept o.value
    @g.send :js_strict_equal, 1

    alt = @g.new_label
    done = @g.new_label
    @g.git alt
    @g.push_true
    @g.goto done

    alt.set!
    @g.push_false
    done.set!
  end

  def visit_BitwiseNotNode(o)
    @g.set_line o.line
    accept o.value
    @g.send :~, 0
  end

  def visit_InstanceOfNode(o)
    @g.set_line o.line
    accept o.left
    accept o.value
    @g.swap
    @g.send :js_instance_of, 1
  end
  def visit_InNode(o)
    @g.set_line o.line
    accept o.left
    accept o.value
    @g.swap
    @g.send :js_in, 1
  end

  def visit_FunctionCallNode(o)
    callee = o.value
    args = o.arguments.value

    case callee
    when RKelly::Nodes::DotAccessorNode
      accept callee.value
      @g.push_literal callee.accessor.to_sym
      args.each do |arg|
        accept arg
      end
      #@g.call_custom :js_invoke, args.size + 1
      @g.send :js_invoke, args.size + 1

    when RKelly::Nodes::BracketAccessorNode
      accept callee.value
      accept callee.left
      @g.send :js_key, 0
      args.each do |arg|
        accept arg
      end
      #@g.call_custom :js_invoke, args.size + 1
      @g.send :js_invoke, args.size + 1

    else
      accept callee
      args.each do |arg|
        accept arg
      end
      @g.send :call, args.size
    end
  end
  def assign_to(o)
    @g.set_line o.line
    case o
    when RKelly::Nodes::ResolveNode
      if ref = @g.state.scope.search_local(o.value.to_sym)
        ref.set_bytecode(@g)
      else
        @g.push_const :Capuchin
        @g.find_const :Globals
        @g.swap
        @g.push_literal o.value.to_sym
        @g.swap
        @g.send :[]=, 2
      end
    when RKelly::Nodes::DotAccessorNode
      accept o.value
      @g.swap
      @g.push_literal o.accessor.to_sym
      @g.swap
      @g.send :js_set, 2
    when RKelly::Nodes::BracketAccessorNode
      accept o.value
      @g.swap
      accept o.accessor
      @g.send :js_key, 0
      @g.swap
      @g.send :js_set, 2
    else
      raise "Don't know how to assign to #{o.class}"
    end
  end
  def visit_OpEqualNode(o)
    accept o.value
    assign_to o.left
  end

  [
    [:OpAndEqual, '&='],
    [:OpDivideEqual, '/='],
    [:OpLShiftEqual, '<<='],
    [:OpMinusEqual, '-='],
    [:OpModEqual, '%='],
    [:OpMultiplyEqual, '*='],
    [:OpOrEqual, '|='],
    [:OpPlusEqual, '+='],
    [:OpRShiftEqual, '>>='],
    [:OpURShiftEqual, '>>>='],
    [:OpXOrEqual, '^='],
  ].each do |name,op|
    define_method(:"visit_#{name}Node") do |o|
      # Need to address double-evaluation of o.left
      raise NotImplementedError, "#{name}Node"
      "#{o.left.accept(self)} #{op} #{o.value.accept(self)}"
    end
  end
end

